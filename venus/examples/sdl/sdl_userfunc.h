/*
	Description: 	Do not edit this file manually
	Author:			SDL Compiler
*/

#ifndef SDL_USERFUNC_H
#define SDL_USERFUNC_H

#ifndef SDL_USERFUNC_BASE_H
#include "sdl_userfunc_base.h"
#endif

#ifndef VENUS_CONNECTION_H
#include <venus/Connection.h>
#endif

#pragma pack(1)

namespace userfunc {


class Calc : public cerl::Connection, public CalcBase
{
public:
	Calc()
	{}

	Calc(const cerl::Connection& conn)
		: cerl::Connection(conn)
	{}

	bool cerl_call square(cerl::ScopedAlloc& alloc,
		_SquareResult& _result,
		const cerl::UInt32 number
		)
	{
		return cerl::Connection::dbg_call(this, alloc, _result, (cerl::FID)code_square, number);
	}

	bool cerl_call add(cerl::ScopedAlloc& alloc,
		_AddResult& _result,
		const NUM32 number1,
		const NUM32 number2
		)
	{
		_AddArgs _args = {number1, number2};
		return cerl::Connection::dbg_call(this, alloc, _result, (cerl::FID)code_add, _args);
	}

	bool cerl_call dec(cerl::ScopedAlloc& alloc,
		_DecResult& _result,
		const cerl::UInt32 number1,
		const cerl::UInt32 number2,
		const cerl::UInt32 number3
		)
	{
		_DecArgs _args = {number1, number2, number3};
		return cerl::Connection::dbg_call(this, alloc, _result, (cerl::FID)code_dec, _args);
	}

	bool cerl_call helloworld1(cerl::ScopedAlloc& alloc,
		_Helloworld1Result& _result
		)
	{
		return cerl::Connection::dbg_call0(this, alloc, _result, (cerl::FID)code_helloworld1);
	}

	bool cerl_call helloworld2(cerl::ScopedAlloc& alloc,
		_Helloworld2Result& _result
		)
	{
		return cerl::Connection::dbg_call0(this, alloc, _result, (cerl::FID)code_helloworld2);
	}

	bool cerl_call square2(cerl::ScopedAlloc& alloc,
		_Square2Result& _result,
		const NUM number
		)
	{
		return cerl::Connection::dbg_call(this, alloc, _result, (cerl::FID)code_square2, number);
	}

	/*[async]*/
	bool cerl_call stop()
	{
		return cerl::Connection::dbg_cast0(this, (cerl::FID)code_stop);
	}

	/*[async]*/
	bool cerl_call async1(const cerl::UInt32 number1
		)
	{
		return cerl::Connection::dbg_cast(this, (cerl::FID)code_async1, number1);
	}

	/*[async]*/
	bool cerl_call async2(const cerl::UInt32 number1,
		const cerl::UInt32 number2
		)
	{
		_Async2Args _args = {number1, number2};
		return cerl::Connection::dbg_cast(this, (cerl::FID)code_async2, _args);
	}
};

class SyncCalc : public CalcBase
{
private:
	cerl::SyncConnection& m_conn;

public:
	SyncCalc(cerl::SyncConnection& conn)
		: m_conn(conn)
	{}

	bool cerl_call square(cerl::ScopedAlloc& alloc,
		_SquareResult& _result,
		const cerl::UInt32 number
		)
	{
		return m_conn.dbg_call(this, alloc, _result, (cerl::FID)code_square, number);
	}

	bool cerl_call add(cerl::ScopedAlloc& alloc,
		_AddResult& _result,
		const NUM32 number1,
		const NUM32 number2
		)
	{
		_AddArgs _args = {number1, number2};
		return m_conn.dbg_call(this, alloc, _result, (cerl::FID)code_add, _args);
	}

	bool cerl_call dec(cerl::ScopedAlloc& alloc,
		_DecResult& _result,
		const cerl::UInt32 number1,
		const cerl::UInt32 number2,
		const cerl::UInt32 number3
		)
	{
		_DecArgs _args = {number1, number2, number3};
		return m_conn.dbg_call(this, alloc, _result, (cerl::FID)code_dec, _args);
	}

	bool cerl_call helloworld1(cerl::ScopedAlloc& alloc,
		_Helloworld1Result& _result
		)
	{
		return m_conn.dbg_call0(this, alloc, _result, (cerl::FID)code_helloworld1);
	}

	bool cerl_call helloworld2(cerl::ScopedAlloc& alloc,
		_Helloworld2Result& _result
		)
	{
		return m_conn.dbg_call0(this, alloc, _result, (cerl::FID)code_helloworld2);
	}

	bool cerl_call square2(cerl::ScopedAlloc& alloc,
		_Square2Result& _result,
		const NUM number
		)
	{
		return m_conn.dbg_call(this, alloc, _result, (cerl::FID)code_square2, number);
	}

	/*[async]*/
	bool cerl_call stop()
	{
		return m_conn.dbg_cast0(this, (cerl::FID)code_stop);
	}

	/*[async]*/
	bool cerl_call async1(const cerl::UInt32 number1
		)
	{
		return m_conn.dbg_cast(this, (cerl::FID)code_async1, number1);
	}

	/*[async]*/
	bool cerl_call async2(const cerl::UInt32 number1,
		const cerl::UInt32 number2
		)
	{
		_Async2Args _args = {number1, number2};
		return m_conn.dbg_cast(this, (cerl::FID)code_async2, _args);
	}
};

} //namespace

#pragma pack()

#endif /* SDL_USERFUNC_H */ 
