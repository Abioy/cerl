/*
	Description: 	Do not edit this file manually
	Author:			SDL Compiler
*/

#ifndef USERFUNC_CALC_STUB_H
#define USERFUNC_CALC_STUB_H

#ifndef USERFUNC_CALC_IMPL_H
#include "CalcImpl.h"
#endif

namespace userfunc {

class CalcStub : public CalcImpl
{
public:
	template <class ArchiveT>
	void cerl_call _process(cerl::Caller* _caller, ArchiveT& _ar)
	{
		Caller* const caller = static_cast<Caller*>(_caller);
		cerl::FID fid = caller->getFid();
		if (is_async_call(fid))
		{
			_handle_cast(caller, fid, _ar);
		}
		else
		{
			_handle_call(caller, fid, _ar);
		}
	}

	template <class ArchiveT>
	void cerl_call _handle_cast(Caller* caller, cerl::FID _fid, ArchiveT& _ar)
	{
		switch (_fid)
		{
		case code_stop:
			{
				NS_CERL_IO::check_vt_null(_ar);
				stop(caller);
			}
			break;
		case code_async1:
			{
				_Async1Args _args;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				CERL_ASSERT(_fOk && "Calc::_handle_cast - async1");
				if (_fOk)
					async1(caller, _args);
			}
			break;
		case code_async2:
			{
				_Async2Args _args;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				CERL_ASSERT(_fOk && "Calc::_handle_cast - async2");
				if (_fOk)
					async2(caller, _args.number1, _args.number2);
			}
			break;
		default:
			{
				skipMailBody(_ar);
				CERL_TRACE("cerl::handle_cast - Unknown FID: %.8X", _fid);
			}
			break;
		}
	}

	template <class ArchiveT>
	void cerl_call _handle_call(Caller* caller, cerl::FID _fid, ArchiveT& _ar)
	{
		switch (_fid)
		{
		case code_square:
			{
				_SquareArgs _args;
				_SquareResult _result = cerl::code_unknown_error;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				if (_fOk)
				{
					CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
					square(caller, _result, _args);
				}

				caller->dbg_reply(this, _result);
			}
			break;
		case code_add:
			{
				_AddArgs _args;
				_AddResult _result = cerl::code_unknown_error;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				if (_fOk)
				{
					CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
					add(caller, _result, _args.number1, _args.number2);
				}

				caller->dbg_reply(this, _result);
			}
			break;
		case code_dec:
			{
				_DecArgs _args;
				_DecResult _result = cerl::code_unknown_error;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				if (_fOk)
				{
					CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
					dec(caller, _result, _args.number1, _args.number2, _args.number3);
				}

				caller->dbg_reply(this, _result);
			}
			break;
		case code_helloworld1:
			{
				cerl::NoArgs _args;
				(void) _args;
				_Helloworld1Result _result = cerl::code_unknown_error;
				NS_CERL_IO::check_vt_null(_ar);
				CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
				helloworld1(caller, _result);

				caller->dbg_reply(this, _result);
			}
			break;
		case code_helloworld2:
			{
				cerl::NoArgs _args;
				(void) _args;
				_Helloworld2Result _result = cerl::code_unknown_error;
				NS_CERL_IO::check_vt_null(_ar);
				CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
				helloworld2(caller, _result);

				caller->dbg_reply(this, _result);
			}
			break;
		case code_square2:
			{
				_Square2Args _args;
				_Square2Result _result = cerl::code_unknown_error;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				if (_fOk)
				{
					CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
					square2(caller, _result, _args);
				}

				caller->dbg_reply(this, _result);
			}
			break;
		default:
			{
				cerl::handle_call(this, caller, _fid, _ar);
			}
			break;
		}
	}
};

inline void cerl_call CalcImpl::_run(cerl::Fiber self, SOCKET socketListen)
{
	cerl::ServerRunner<CalcStub>::run(self, static_cast<CalcStub*>(this), socketListen);
}

} //namespace

#endif /* USERFUNC_CALC_STUB_H */ 
