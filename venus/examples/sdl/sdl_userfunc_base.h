/*
	Description: 	Do not edit this file manually
	Author:			SDL Compiler
*/

#ifndef SDL_USERFUNC_BASE_H
#define SDL_USERFUNC_BASE_H

#ifndef VENUS_IO_H
#include <venus/Io.h>
#endif

#pragma pack(1)

namespace userfunc {

enum { code_ok = cerl::code_ok };
enum { code_error = cerl::code_error };
enum { code_true = cerl::code_true };
enum { code_false = cerl::code_false };
enum { code_confliction = 0x81 };
enum { code_notimpl = 0x82 };

typedef cerl::UInt64 NUM;

typedef cerl::UInt32 NUM32;

typedef cerl::Code Reason;

typedef struct {
	cerl::String s;
	cerl::UInt32 n;
} Bar;

typedef struct {
	cerl::UInt32 n;
	cerl::String s;
	cerl::Char c;
	cerl::Bool b;
	cerl::BasicArray<Bar> bars;
} Foo;

class CalcBase
{
public:
	enum { code_square = 1 };
	enum { code_add = 2 };
	enum { code_dec = 3 };
	enum { code_helloworld1 = 4 };
	enum { code_helloworld2 = 5 };
	enum { code_square2 = 6 };
	enum { code_stop = 0x81 | CERL_FID_ASYNC_MASK };
	enum { code_async1 = 0x91 | CERL_FID_ASYNC_MASK };
	enum { code_async2 = 0xa1 | CERL_FID_ASYNC_MASK };

#if defined(VENUS_DEBUG_H)
	static const char* cerl_call _fid2name(cerl::FID fid)
	{
		static const cerl::Fid2Name g_tbl[] =
		{
			{ code_square, "Calc.square" },
			{ code_add, "Calc.add" },
			{ code_dec, "Calc.dec" },
			{ code_helloworld1, "Calc.helloworld1" },
			{ code_helloworld2, "Calc.helloworld2" },
			{ code_square2, "Calc.square2" },
			{ code_stop, "Calc.stop" },
			{ code_async1, "Calc.async1" },
			{ code_async2, "Calc.async2" },
		};
		return cerl::fid2name(fid, g_tbl, countof(g_tbl));
	}
#endif

// Generated declaration data structure of Argments
//////////////////////////////////////////////////////////////////////////

	typedef cerl::UInt32 _SquareArgs;

	typedef struct {
		NUM32 number1;
		NUM32 number2;
	} _AddArgs;

	typedef struct {
		cerl::UInt32 number1;
		cerl::UInt32 number2;
		cerl::UInt32 number3;
	} _DecArgs;

	typedef NUM _Square2Args;

	typedef cerl::UInt32 _Async1Args;

	typedef struct {
		cerl::UInt32 number1;
		cerl::UInt32 number2;
	} _Async2Args;

// Generated declaration data structure of Result
//////////////////////////////////////////////////////////////////////////

	typedef struct _SquareResultTag {
		cerl::Code _code;
		struct {
			cerl::UInt32 str;
		};

		_SquareResultTag(cerl::Code code = cerl::code_error) {
			_code = code;
		}

		operator cerl::Code() const {
			return _code;
		}

		void cerl_call operator=(cerl::Code code) {
			_code = code;
		}

		template <class LogT>
		void cerl_call dumpCode(LogT& log) const {
			NS_CERL_IO::dumpCode(log, _code);
		}
	} _SquareResult;

	typedef struct _AddResultTag {
		cerl::Code _code;
		struct {
			cerl::UInt32 value;
		};

		_AddResultTag(cerl::Code code = cerl::code_error) {
			_code = code;
		}

		operator cerl::Code() const {
			return _code;
		}

		void cerl_call operator=(cerl::Code code) {
			_code = code;
		}

		template <class LogT>
		void cerl_call dumpCode(LogT& log) const {
			NS_CERL_IO::dumpCode(log, _code);
		}
	} _AddResult;

	typedef struct _DecResultTag {
		cerl::Code _code;
		struct {
			cerl::Int32 value;
		};

		_DecResultTag(cerl::Code code = cerl::code_error) {
			_code = code;
		}

		operator cerl::Code() const {
			return _code;
		}

		void cerl_call operator=(cerl::Code code) {
			_code = code;
		}

		template <class LogT>
		void cerl_call dumpCode(LogT& log) const {
			NS_CERL_IO::dumpCode(log, _code);
		}
	} _DecResult;

	typedef _DecResult _Helloworld1Result;

	typedef struct _Helloworld2ResultTag {
		cerl::Code _code;

		_Helloworld2ResultTag(cerl::Code code = cerl::code_error) {
			_code = code;
		}

		operator cerl::Code() const {
			return _code;
		}

		void cerl_call operator=(cerl::Code code) {
			_code = code;
		}

		template <class LogT>
		void cerl_call dumpCode(LogT& log) const {
			NS_CERL_IO::dumpCode(log, _code);
		}
	} _Helloworld2Result;

	typedef struct _Square2ResultTag {
		cerl::Code _code;
		struct {
			cerl::UInt32 str;
		};
		struct {
			Reason reason;
		}error;

		_Square2ResultTag(cerl::Code code = cerl::code_error) {
			_code = code;
		}

		operator cerl::Code() const {
			return _code;
		}

		void cerl_call operator=(cerl::Code code) {
			_code = code;
		}

		template <class LogT>
		void cerl_call dumpCode(LogT& log) const {
			NS_CERL_IO::dumpCode(log, _code);
		}
	} _Square2Result;
};

} //namespace

#pragma pack()

NS_CERL_IO_BEGIN

// Generated serialization of user types
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::Bar)
	IoTypeTraits<userfunc::Bar>::putType(os);
	NS_CERL_IO::put(os, val.s);
	NS_CERL_IO::put(os, val.n);
CERL_IO_END_PUTTER()


CERL_IO_BEGIN_GETTER(userfunc::Bar)
	if (!IoTypeTraits<userfunc::Bar>::getType(is))
		return false;
	return NS_CERL_IO::get(is, val.s)
		&& NS_CERL_IO::get(is, val.n);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::Bar& dest, const userfunc::Bar& src)
{
	dest = src;
	NS_CERL_IO::copy(alloc, dest.s, src.s);
}
CERL_PODTYPE(userfunc::Bar, false);

template<class LogT>
inline void dump(LogT& log, const userfunc::Bar& args)
{
	NS_CERL_IO::dump(log, '{');
	NS_CERL_IO::dump(log, args.s);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.n);
	NS_CERL_IO::dump(log, '}');
}

CERL_IO_BEGIN_PUTTER(userfunc::Foo)
	IoTypeTraits<userfunc::Foo>::putType(os);
	NS_CERL_IO::put(os, val.n);
	NS_CERL_IO::put(os, val.s);
	NS_CERL_IO::put(os, val.c);
	NS_CERL_IO::put(os, val.b);
	NS_CERL_IO::put(os, val.bars);
CERL_IO_END_PUTTER()


CERL_IO_BEGIN_GETTER(userfunc::Foo)
	if (!IoTypeTraits<userfunc::Foo>::getType(is))
		return false;
	return NS_CERL_IO::get(is, val.n)
		&& NS_CERL_IO::get(is, val.s)
		&& NS_CERL_IO::get(is, val.c)
		&& NS_CERL_IO::get(is, val.b)
		&& NS_CERL_IO::get(is, val.bars);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::Foo& dest, const userfunc::Foo& src)
{
	dest = src;
	NS_CERL_IO::copy(alloc, dest.s, src.s);
	NS_CERL_IO::copy(alloc, dest.bars, src.bars);
}
CERL_PODTYPE(userfunc::Foo, false);

template<class LogT>
inline void dump(LogT& log, const userfunc::Foo& args)
{
	NS_CERL_IO::dump(log, '{');
	NS_CERL_IO::dump(log, args.n);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.s);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.c);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.b);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.bars);
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function square
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function square
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_SquareResult)
	NS_CERL_IO::put(os, val._code);
	switch(val._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::put(os, val.str);
		break;
	default:
		break;
	}
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_SquareResult)
	if (!NS_CERL_IO::get(is, val._code))
		return false;

	switch(val._code)
	{
	case cerl::code_ok:
		return NS_CERL_IO::get(is, val.str);
	default:
		return true;
	}
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_SquareResult& dest, const userfunc::CalcBase::_SquareResult& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_SquareResult, true);

template <class LogT>
inline void cerl_call dump(LogT& log, const userfunc::CalcBase::_SquareResult& result)
{
	NS_CERL_IO::dump(log, '{');
	result.dumpCode(log);
	switch (result._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::dump(log, ", ");
		NS_CERL_IO::dump(log, result.str);
		break;
	default:
		break;
	}
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function add
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_AddArgs)
	NS_CERL_IO::put(os, val.number1);
	NS_CERL_IO::put(os, val.number2);
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_AddArgs)
	return NS_CERL_IO::get(is, val.number1)
		&& NS_CERL_IO::get(is, val.number2);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_AddArgs& dest, const userfunc::CalcBase::_AddArgs& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_AddArgs, true);

template<class LogT>
inline void dump(LogT& log, const userfunc::CalcBase::_AddArgs& args)
{
	NS_CERL_IO::dump(log, '{');
	NS_CERL_IO::dump(log, args.number1);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.number2);
	NS_CERL_IO::dump(log, '}');
}

// Generated Ret serialization for function add
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_AddResult)
	NS_CERL_IO::put(os, val._code);
	switch(val._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::put(os, val.value);
		break;
	default:
		break;
	}
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_AddResult)
	if (!NS_CERL_IO::get(is, val._code))
		return false;

	switch(val._code)
	{
	case cerl::code_ok:
		return NS_CERL_IO::get(is, val.value);
	default:
		return true;
	}
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_AddResult& dest, const userfunc::CalcBase::_AddResult& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_AddResult, true);

template <class LogT>
inline void cerl_call dump(LogT& log, const userfunc::CalcBase::_AddResult& result)
{
	NS_CERL_IO::dump(log, '{');
	result.dumpCode(log);
	switch (result._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::dump(log, ", ");
		NS_CERL_IO::dump(log, result.value);
		break;
	default:
		break;
	}
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function dec
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_DecArgs)
	NS_CERL_IO::put(os, val.number1);
	NS_CERL_IO::put(os, val.number2);
	NS_CERL_IO::put(os, val.number3);
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_DecArgs)
	return NS_CERL_IO::get(is, val.number1)
		&& NS_CERL_IO::get(is, val.number2)
		&& NS_CERL_IO::get(is, val.number3);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_DecArgs& dest, const userfunc::CalcBase::_DecArgs& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_DecArgs, true);

template<class LogT>
inline void dump(LogT& log, const userfunc::CalcBase::_DecArgs& args)
{
	NS_CERL_IO::dump(log, '{');
	NS_CERL_IO::dump(log, args.number1);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.number2);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.number3);
	NS_CERL_IO::dump(log, '}');
}

// Generated Ret serialization for function dec
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_DecResult)
	NS_CERL_IO::put(os, val._code);
	switch(val._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::put(os, val.value);
		break;
	default:
		break;
	}
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_DecResult)
	if (!NS_CERL_IO::get(is, val._code))
		return false;

	switch(val._code)
	{
	case cerl::code_ok:
		return NS_CERL_IO::get(is, val.value);
	default:
		return true;
	}
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_DecResult& dest, const userfunc::CalcBase::_DecResult& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_DecResult, true);

template <class LogT>
inline void cerl_call dump(LogT& log, const userfunc::CalcBase::_DecResult& result)
{
	NS_CERL_IO::dump(log, '{');
	result.dumpCode(log);
	switch (result._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::dump(log, ", ");
		NS_CERL_IO::dump(log, result.value);
		break;
	default:
		break;
	}
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function helloworld1
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function helloworld1
//////////////////////////////////////////////////////////////////////////

// Generated Args serialization for function helloworld2
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function helloworld2
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_Helloworld2Result)
	NS_CERL_IO::put(os, val._code);
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_Helloworld2Result)
	return NS_CERL_IO::get(is, val._code);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_Helloworld2Result& dest, const userfunc::CalcBase::_Helloworld2Result& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_Helloworld2Result, true);

template <class LogT>
inline void cerl_call dump(LogT& log, const userfunc::CalcBase::_Helloworld2Result& result)
{
	NS_CERL_IO::dump(log, '{');
	result.dumpCode(log);
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function square2
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function square2
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_Square2Result)
	NS_CERL_IO::put(os, val._code);
	switch(val._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::put(os, val.str);
		break;
	case cerl::code_error:
		NS_CERL_IO::put(os, val.error.reason);
		break;
	default:
		break;
	}
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_Square2Result)
	if (!NS_CERL_IO::get(is, val._code))
		return false;

	switch(val._code)
	{
	case cerl::code_ok:
		return NS_CERL_IO::get(is, val.str);
	case cerl::code_error:
		return NS_CERL_IO::get(is, val.error.reason);
	default:
		return true;
	}
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_Square2Result& dest, const userfunc::CalcBase::_Square2Result& src)
{
	dest = src;
	switch(src._code)
	{
	case cerl::code_error:
		NS_CERL_IO::copy(alloc, dest.error.reason, src.error.reason);
		break;
	default:
		break;
	}
}
CERL_PODTYPE(userfunc::CalcBase::_Square2Result, false);

template <class LogT>
inline void cerl_call dump(LogT& log, const userfunc::CalcBase::_Square2Result& result)
{
	NS_CERL_IO::dump(log, '{');
	result.dumpCode(log);
	switch (result._code)
	{
	case cerl::code_ok:
		NS_CERL_IO::dump(log, ", ");
		NS_CERL_IO::dump(log, result.str);
		break;
	case cerl::code_error:
		NS_CERL_IO::dump(log, ", ");
		NS_CERL_IO::dump(log, result.error.reason);
		break;
	default:
		break;
	}
	NS_CERL_IO::dump(log, '}');
}

// Generated Args serialization for function stop
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function stop
//////////////////////////////////////////////////////////////////////////

// Generated Args serialization for function async1
//////////////////////////////////////////////////////////////////////////

// Generated Ret serialization for function async1
//////////////////////////////////////////////////////////////////////////

// Generated Args serialization for function async2
//////////////////////////////////////////////////////////////////////////

CERL_IO_BEGIN_PUTTER(userfunc::CalcBase::_Async2Args)
	NS_CERL_IO::put(os, val.number1);
	NS_CERL_IO::put(os, val.number2);
CERL_IO_END_PUTTER()

CERL_IO_BEGIN_GETTER(userfunc::CalcBase::_Async2Args)
	return NS_CERL_IO::get(is, val.number1)
		&& NS_CERL_IO::get(is, val.number2);
CERL_IO_END_GETTER()

template <class AllocT>
inline void copy(AllocT& alloc, userfunc::CalcBase::_Async2Args& dest, const userfunc::CalcBase::_Async2Args& src)
{
	dest = src;
}
CERL_PODTYPE(userfunc::CalcBase::_Async2Args, true);

template<class LogT>
inline void dump(LogT& log, const userfunc::CalcBase::_Async2Args& args)
{
	NS_CERL_IO::dump(log, '{');
	NS_CERL_IO::dump(log, args.number1);
	NS_CERL_IO::dump(log, ", ");
	NS_CERL_IO::dump(log, args.number2);
	NS_CERL_IO::dump(log, '}');
}

// Generated Ret serialization for function async2
//////////////////////////////////////////////////////////////////////////

NS_CERL_IO_END

#ifndef VENUS_IO_INL
#include <venus/Io.inl>
#endif
#endif /* SDL_USERFUNC_BASE_H */ 
