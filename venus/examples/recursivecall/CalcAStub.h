/*
	Description: 	Do not edit this file manually
	Author:			SDL Compiler
*/

#ifndef RECURSIVECALL_CALCA_STUB_H
#define RECURSIVECALL_CALCA_STUB_H

#ifndef RECURSIVECALL_CALCA_IMPL_H
#include "CalcAImpl.h"
#endif

namespace recursivecall {

class CalcAStub : public CalcAImpl
{
public:
	template <class ArchiveT>
	void cerl_call _process(cerl::Caller* _caller, ArchiveT& _ar)
	{
		Caller* const caller = static_cast<Caller*>(_caller);
		cerl::FID fid = caller->getFid();
		if (is_async_call(fid))
		{
			_handle_cast(caller, fid, _ar);
		}
		else
		{
			_handle_call(caller, fid, _ar);
		}
	}

	template <class ArchiveT>
	void cerl_call _handle_cast(Caller* caller, cerl::FID _fid, ArchiveT& _ar)
	{
			skipMailBody(_ar);
			CERL_TRACE("cerl::handle_cast - Unknown FID: %.8X", _fid);
	}

	template <class ArchiveT>
	void cerl_call _handle_call(Caller* caller, cerl::FID _fid, ArchiveT& _ar)
	{
		switch (_fid)
		{
		case code_add:
			{
				_AddArgs _args;
				_AddResult _result = cerl::code_unknown_error;
				const bool _fOk = cerl::getMailBody(_ar, _args);

				if (_fOk)
				{
					CERL_DUMP_RECV_REQUEST(caller->getSelf(), this, _fid, _args);
					add(caller, _result, _args.node, _args.number1, _args.number2);
				}

				caller->dbg_reply(this, _result);
			}
			break;
		default:
			{
				cerl::handle_call(this, caller, _fid, _ar);
			}
			break;
		}
	}
};

inline void cerl_call CalcAImpl::_run(cerl::Fiber self, SOCKET socketListen)
{
	cerl::ServerRunner<CalcAStub>::run(self, static_cast<CalcAStub*>(this), socketListen);
}

} //namespace

#endif /* RECURSIVECALL_CALCA_STUB_H */ 
