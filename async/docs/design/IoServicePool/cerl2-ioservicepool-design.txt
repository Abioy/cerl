/*
	Description:	Design of ioservice pool mechanism supported in library async, part of CERL 2.0
	Author:			Wanghuan [wanghuan@gmail.com]
	Date:			2010-Feb-01
*/

注： Design文档中提到的名词并不一定在具体的代码实现中采用，这里只描述概念

1. 概要
--
在async库中，服务器端采用可采用单线程模式，如现在的IoService模型，通过一个线程中的IoService的多纤程来支持多个并发的服务请求，服务器，线程与请求（纤程）关系为 1:1:M。
同时我们也希望服务器端可以用多线程模型，也就是说，我们可以有多个线程，每个线程中有一个IoService实例，每个IoService实例逻辑上有多个纤程，现在服务器，线程，与请求的关系
变为1:M:M*N。

这种多线程模式特别适合于httpd这类不同用户请求之间关联很小的模型，因为请求之间关联小，数据共享的就少，就不需要多线程共享数据，否则多线程共享数据需要同步会影响整体性能。
（线程mutex比纤程mutex更重量。）

2. 规格
--
提供 IoServicePool 类来使用单线程或者多线程模型。通过定义CERL_MULTI_IOSERVICE宏来决定是否使用MultiIoService，也就是多线程模型。
在 IoServicePool 中必须提供 1.init()成员函数，用来初始化线程池；2.quit()成员函数，用来退出线程池；3.startSession()函数，用来取代
单线程模型中的 startFiber() 函数，也就是说单线程情况下在当前线程中创建一个 Fiber 来完成的具体业务逻辑，在多线程模型中则会启动一个Session
来完成，Session 的概念就是对一个请求的一个处理过程。这个 Session 可以在线程池的不同的线程的 IoService 中启动纤程来完成具体业务逻辑。

在以前的模型中，一个 IoService 通过 startFiber 来处理客户端请求，而现在则通过 startSession 来处理。退出的过程也发生变化，以前只需要 IoServer->quit() 就可以往消息队列
发送退出信息，各个纤程分别退出并释放资源。在新的模型中，则需要调用 IoServicePool 中的quit()来让所有的 IoService 都退出。

3. 来由
--
最初的设计系统中应该有一个全局TaskPool，也就是所谓的MultiThreadPool，多个线程同时共享一个 Task 队列。也就是说线程与纤程是一个 M:N 的关系，这就带来一个问题，因为系统
中纤程数目远远大于线程，如果到某个服务器的连接断开，线程池中的线程很快就会被工作纤程用光直到超时，在超时之前将没有可用线程连接其他可用服务器，这将大大影响系统性能。

解决这个问题的思路是让服务器出现问题的影响被限制在局部范围之内。用了上述多线程，每个线程多个纤程的模型之后，当一个线程被阻塞之后，对于其他服务器的连接还能被调度到其他
线程的纤程中执行。

在上述模型中，由于存在多线程，线程中又存在多纤程，所有在访问共享数据取锁的时候可能得取一个线程纤程混合锁，或者先后一次取到线程锁和纤程锁，释放时则要先释放纤程锁，再释
放线程锁。